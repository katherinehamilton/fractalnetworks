<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fractalnetworks.modelgenerator &#8212; Fractal Networks 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for fractalnetworks.modelgenerator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module contains functions to generate instances of known fractal network models&quot;&quot;&quot;</span>

<span class="c1"># Network analysis modules</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="c1"># Mathematics modules</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Utility modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>


<span class="c1"># SHM Model</span>


<div class="viewcode-block" id="generate_SHM_model">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_SHM_model">[docs]</a>
<span class="k">def</span> <span class="nf">generate_SHM_model</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an n-th generation SHM network with parameters m and p.</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int): The number of offspring added at each stage, as defined by the SHM model [3].</span>
<span class="sd">        p (float): The probability of rewiring an edge, as defined by the SHM model [3]. The value of p should be between 0 and 1.</span>
<span class="sd">        n (int): The number of iterations to perform of the SHM generative process [3].</span>
<span class="sd">        save (bool) (opt): If True, the file is saved to the network-files folder. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The generated SHM network.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># In the first generation the network is a path of length 2.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Generate the next generation n-1 more times.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">SHM_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Save the file is save is True.</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="c1"># Save the file in the format SHM-model-m-p-generationn-examplei.gml</span>
        <span class="c1"># For p != 0 the method is non-deterministic and so multiple examples need to be saved.</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Initialise a Boolean variable to False, where False means that it is yet to be saved, and True means it has been saved.</span>
        <span class="n">saved</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Iterate while the file is yet to be saved.</span>
        <span class="k">while</span> <span class="n">saved</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;SHM-model-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-generation&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-example&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.gml&quot;</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;network-files/models/SHM-model/&quot;</span> <span class="o">+</span> <span class="n">filename</span>
            <span class="c1"># If the count-th example already exists, increment the count by 1 and try to save again.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>
                <span class="n">saved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return the generated graph</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="SHM_iteration">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.SHM_iteration">[docs]</a>
<span class="k">def</span> <span class="nf">SHM_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs one iteration of the generative process for the SHM model.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.Graph): The network from the previous generation.</span>
<span class="sd">        m (int): The number of offspring added at each stage, as defined by the SHM model [3].</span>
<span class="sd">        p (float): The probability of rewiring an edge, as defined by the SHM model [3]. The value of p should be between 0 and 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The network in the new generation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find a list of all existing edges in the network.</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="c1"># For each edge, add m offspring to each endpoint of the edge.</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">source_offspring</span> <span class="o">=</span> <span class="n">add_m_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">target_offspring</span> <span class="o">=</span> <span class="n">add_m_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># With probability p, rewire the original edge.</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">rewire_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">source_offspring</span><span class="p">,</span> <span class="n">target_offspring</span><span class="p">)</span>

    <span class="c1"># Return the updated network.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="add_m_offspring">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.add_m_offspring">[docs]</a>
<span class="k">def</span> <span class="nf">add_m_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds m offspring to a given node, connected by a single edge.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.Graph): The network in its current state.</span>
<span class="sd">        node (int): The node to which the offspring are to be added.</span>
<span class="sd">        m (int): The number of offspring.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The updated network.</span>
<span class="sd">        new_nodes (list): A list of the names of all the new nodes added at the previous stage.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the number of nodes in the network</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="c1"># Add new nodes, named for the next available i integers.</span>
    <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
    <span class="c1"># Create a list of new edges, one connecting each new node to the original node.</span>
    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Add the new edges and vertices</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>

    <span class="c1"># Return the updated graph, and a list of the new nodes.</span>
    <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">new_nodes</span></div>



<div class="viewcode-block" id="rewire_offspring">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.rewire_offspring">[docs]</a>
<span class="k">def</span> <span class="nf">rewire_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">source_offspring</span><span class="p">,</span> <span class="n">target_offspring</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rewires a given edge, replacing it with an edge between two randomly chosen offspring of the current endpoints [3].</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.Graph): The network in its current state.</span>
<span class="sd">        edge (tuple): The edge to be rewired.</span>
<span class="sd">        source_offspring (list): A list of offspring of the source node.</span>
<span class="sd">        target_offspring (list): A list of offspring of the target node.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The updated network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove the original edge.</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Choose a new source at random from the original source node&#39;s offspring.</span>
    <span class="n">new_source</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">source_offspring</span><span class="p">)</span>
    <span class="c1"># Choose a new target at random from the original target node&#39;s offspring.</span>
    <span class="n">new_target</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">target_offspring</span><span class="p">)</span>

    <span class="c1"># Add a new edge between the new source and target.</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_source</span><span class="p">,</span> <span class="n">new_target</span><span class="p">)</span>

    <span class="c1"># Return the updated network.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="generate_SHM_model_for_all_p">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_SHM_model_for_all_p">[docs]</a>
<span class="k">def</span> <span class="nf">generate_SHM_model_for_all_p</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prob_N</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">example_N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate SHM networks for a fixed m and n, for multiple values of p.</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int): The number of offspring added at each stage, as defined by the SHM model [3].</span>
<span class="sd">        n (int): The number of iterations to perform of the SHM generative process [3].</span>
<span class="sd">        prob_N (int): The number of probabilities to generate the graph for. Default is 11, so will generate networks with p in [0.0, 0.1, 0.2, ..., 0.9, 1.0]</span>
<span class="sd">        example_N (int) (opt): The number of networks of each probability to generate. Default is 1.</span>
<span class="sd">        save (Bool) (opt): If True, save each of the networks to a .gml file. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        probabilities (numpy.ndarray): A list of the probabilities which are used.</span>
<span class="sd">        graphs (list): A list of lists of generated networks. The sublist graphs[i] contains graphs with p=probabilities[i].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate the list of probabilities p.</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prob_N</span><span class="p">)</span>

    <span class="c1"># Initialise an empty list to store networks.</span>
    <span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate for each probability.</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="p">:</span>
        <span class="c1"># Initialise an empty list to store networks with probability p.</span>
        <span class="n">p_graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Generate such a network and add it to the list.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">example_N</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">generate_SHM_model</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)</span>
            <span class="n">p_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="c1"># Add the list of networks with probability p to the overall list.</span>
        <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_graphs</span><span class="p">)</span>

    <span class="c1"># Return a list of probabilities and graphs.</span>
    <span class="k">return</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">graphs</span></div>



<div class="viewcode-block" id="retrieve_SHM_model">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.retrieve_SHM_model">[docs]</a>
<span class="k">def</span> <span class="nf">retrieve_SHM_model</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">example</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the parameters m, p, n and the example number, retrieve the file containing the SHM network.</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int): The number of offspring added at each stage, as defined by the SHM model [3].</span>
<span class="sd">        p (float): The probability of rewiring an edge, as defined by the SHM model [3].</span>
<span class="sd">        n (int): The number of iterations to perform of the SHM generative process [3].</span>
<span class="sd">        example (int) (opt): In the case of multiple graphs with the same parameters, specifies the example wanted. Default is 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The saved SHM network with the above specified parameters.</span>
<span class="sd">        filepath + filename (str): The filepath to the network file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find the filepath to the model with these parameters.</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;SHM-model-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-generation&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-example&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.gml&quot;</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;network-files/models/SHM-model/&quot;</span>

    <span class="c1"># Read the network.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_gml</span><span class="p">(</span><span class="n">filepath</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>

    <span class="c1"># Return the networkx graph.</span>
    <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="n">filename</span></div>


<span class="c1"># HADG Model</span>

<div class="viewcode-block" id="generate_HADG_model">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_HADG_model">[docs]</a>
<span class="k">def</span> <span class="nf">generate_HADG_model</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an nth generation HADG network with parameters m, a, b and T [4][5].</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int): The number of offspring added at each stage, as according to [5].</span>
<span class="sd">        a (float): The probability of rewiring an edge if node degree is over the threshold [5].</span>
<span class="sd">        b (float): The probability of rewiring an edge otherwise [5].</span>
<span class="sd">        T (float): The threshold as according to [5].</span>
<span class="sd">        n (int): The number of iterations to perform of the HADG generative process.</span>
<span class="sd">        save (Bool) (opt): If True, saved the resulting network to a gml file. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The resulting HADG network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In the first generation the network is a path of length 2.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Apply the generative process n-1 more times.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">HADG_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

    <span class="c1"># Save the file is save is True.</span>
    <span class="k">if</span> <span class="n">save</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Save the file in the format HADG-model-m-a-b-T-generationn-examplei.gml</span>
        <span class="c1"># The method is non-deterministic and so multiple examples need to be saved.</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Initialise a Boolean variable to False, where False means that it is yet to be saved, and True means it has been saved.</span>
        <span class="n">saved</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Iterate while the file is yet to be saved.</span>
        <span class="k">while</span> <span class="n">saved</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;HADG-model-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-generation&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-example&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.gml&quot;</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;network-files/models/HADG-model/&quot;</span> <span class="o">+</span> <span class="n">filename</span>
            <span class="c1"># If the count-th example already exists, increment the count by 1 and try to save again.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>
                <span class="n">saved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return the generated graph.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="HADG_iteration">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.HADG_iteration">[docs]</a>
<span class="k">def</span> <span class="nf">HADG_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs one iteration of the HADG generative process [4][5].</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.Graph): The network in its current state.</span>
<span class="sd">        m (int): The number of offspring added at each stage, as according to [5].</span>
<span class="sd">        a (float): The probability of rewiring an edge if node degree is over the threshold [5].</span>
<span class="sd">        b (float): The probability of rewiring an edge otherwise [5].</span>
<span class="sd">        T (float): The threshold as according to [5].</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The updated network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise a dictionary where each node is a key and each value starts as an empty list.</span>
    <span class="c1"># This dictionary will store a list of the newly added nodes to which a previously existing node is adjacent.</span>
    <span class="n">new_node_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span> <span class="p">[])</span>

    <span class="c1"># Find a list of the edges in the previous generation.</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    <span class="c1"># Find a list of the node degrees in the previous generation.</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>

    <span class="c1"># Iterate through each of the edges in the previous generation.</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="c1"># Add m offspring to the source node of the edge.</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">source_offspring</span> <span class="o">=</span> <span class="n">add_m_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Add m offspring to the target node of the edge.</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">target_offspring</span> <span class="o">=</span> <span class="n">add_m_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># Find the degree of the source node in the previous generation.</span>
        <span class="n">degx</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Find the degree of the target node in the previous generation.</span>
        <span class="n">degy</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># Find the maximum degree in the previous generation.</span>
        <span class="n">degmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">degrees</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">degrees</span><span class="p">])</span>

        <span class="c1"># If the degree of both the source and target node, relative to the maximum degree, are over the threshold then</span>
        <span class="c1">#    rewire the edge with probability a.</span>
        <span class="k">if</span> <span class="n">degx</span> <span class="o">/</span> <span class="n">degmax</span> <span class="o">&gt;</span> <span class="n">T</span> <span class="ow">and</span> <span class="n">degy</span> <span class="o">/</span> <span class="n">degmax</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">rewire_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">source_offspring</span><span class="p">,</span> <span class="n">target_offspring</span><span class="p">)</span>
        <span class="c1"># Otherwise rewire the edge with probability b.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">rewire_offspring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">source_offspring</span><span class="p">,</span> <span class="n">target_offspring</span><span class="p">)</span>

        <span class="c1"># Update the dictionary of new neighbours for the source node.</span>
        <span class="n">source_neighbours</span> <span class="o">=</span> <span class="n">new_node_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">source_neighbours</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">source_offspring</span><span class="p">)</span>
        <span class="n">new_node_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">source_neighbours</span>

        <span class="c1"># Update the dictionary of new neighbours for the target node.</span>
        <span class="n">target_neighbours</span> <span class="o">=</span> <span class="n">new_node_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">target_neighbours</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">target_offspring</span><span class="p">)</span>
        <span class="n">new_node_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">target_neighbours</span>

    <span class="c1"># Iterate through each of the nodes from the previous generation.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_node_dict</span><span class="p">:</span>
        <span class="c1"># Find the list of new neighbours for that node.</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">new_node_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="c1"># Find the degree of the node at the previous generation.</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="c1"># Find all possible pairs of new neighbours, i.e. all possible edges between the new offspring of the node.</span>
        <span class="n">possible_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Choose d random new edges where d is the degree of the node at the previous stage.</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">possible_edges</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_edges</span><span class="p">)))</span>
        <span class="c1"># Add these new edges to the network.</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>

    <span class="c1"># Return the updated network.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<span class="c1"># (u,v)-Flower</span>

<div class="viewcode-block" id="generate_uv_flower">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_uv_flower">[docs]</a>
<span class="k">def</span> <span class="nf">generate_uv_flower</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an n-th generation (u,v)-flower.</span>

<span class="sd">    Args:</span>
<span class="sd">        u (int): Value of u, i.e. path length of one of the parallel paths.</span>
<span class="sd">        v (int): Value of v, i.e. path length of one of the parallel paths.</span>
<span class="sd">        n (int): Number of generations.</span>
<span class="sd">        save (bool) (opt): If True, the file is saved to the network-files folder. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The generated (u,v)-flower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise a cycle graph of length w = u + v</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

    <span class="c1"># For each of the n-1 remaining generations, perform one iteration of the generative process.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">uv_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="c1"># Save the file in the format uvflower-generationn.gml</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_flower-generation&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.gml&quot;</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;network-files/models/uv-flowers/&quot;</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="uv_iteration">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.uv_iteration">[docs]</a>
<span class="k">def</span> <span class="nf">uv_iteration</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs one iteration in the (u,v)-flower generation process.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.Graph): The (u,v)-flower network in its current (t-1)-th generation.</span>
<span class="sd">        u (int): Value of u, i.e. path length of one of the parallel paths.</span>
<span class="sd">        v (int): Value of v, i.e. path length of one of the parallel paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The (u,v)-flower network in the t-th generation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find a list of all the nodes and edges in the network at the (t-1)-th generation.</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="c1"># Remove all the existing edges.</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="c1"># Iterate through each of the edges from the network in the (t-1)-th generation.</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="c1"># n is used to store the smallest integer which isn&#39;t yet a node label.</span>
        <span class="c1"># The nodes are labelled 0, ..., n-1, so this is n.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

        <span class="c1"># Replace the edge with a path of length u.</span>
        <span class="c1"># First find a path graph using these vertices.</span>
        <span class="n">Hu</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">add_new_path</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
        <span class="c1"># Then merge this path graph with the existing network.</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Hu</span><span class="p">)</span>

        <span class="c1"># Replace the edge with a path of length v.</span>
        <span class="c1"># First find a path graph using these vertices.</span>
        <span class="n">Hv</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">add_new_path</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
        <span class="c1"># Then merge this path graph with the existing network.</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Hv</span><span class="p">)</span>

    <span class="c1"># Return the graph after all iterations.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="generate_non_fractal_uv_flower">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_non_fractal_uv_flower">[docs]</a>
<span class="k">def</span> <span class="nf">generate_non_fractal_uv_flower</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a non-fractal (u,v)-flower with u=1.</span>

<span class="sd">    Args:</span>
<span class="sd">        v (int): Value of v, i.e. path length of the parallel paths.</span>
<span class="sd">        n (int): Number of generations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (networkx.Graph): The generated (u,v)-flower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Returns the (u,v)-flower found by the fractal generator, but with u hardcoded as 1.</span>
    <span class="k">return</span> <span class="n">generate_uv_flower</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_new_path">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.add_new_path">[docs]</a>
<span class="k">def</span> <span class="nf">add_new_path</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a new parallel path to the network, a step in the (u, v)-flower generation process.</span>

<span class="sd">    Args:</span>
<span class="sd">        l (int): The length of the path to be added to the network.</span>
<span class="sd">        N (int): A counter which stores the next unused integer to label nodes.</span>
<span class="sd">        edge (tuple): The edge from the network being replaced with parallel paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Hl (networkx.Graph): A path graph of length l with vertices labelled correctly.</span>
<span class="sd">        N (int): A counter which stores the next unused integer to label nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate a path graph with l edges (and l+1 vertices).</span>
    <span class="n">Hl</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Create an empty dictionary to be used to relabel the nodes in the path.</span>
    <span class="n">l_rlbl</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">Hl</span><span class="o">.</span><span class="n">nodes</span><span class="p">)}</span>

    <span class="c1"># The nodes in the path graph are labelled from 0 to l.</span>
    <span class="c1"># Thus, the node 0 in this path corresponds to the source node of the original edge,</span>
    <span class="c1">#   and the node l in this path corresponds to the target node of the original edge.</span>

    <span class="c1"># Iterate through all the nodes in the path.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">Hl</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
        <span class="c1"># If the node is 0 in the path, relabel it as the source of the original edge.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l_rlbl</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If the node is l in the path, relabel it as the source of the original edge.</span>
        <span class="k">elif</span> <span class="n">node</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">l_rlbl</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># For all other nodes, relabel it as the next unused integer.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_rlbl</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
            <span class="c1"># Increment the counter n, so that n is now the next unused integer.</span>
            <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Relabel the nodes according to the scheme described above.</span>
    <span class="n">Hl</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">Hl</span><span class="p">,</span> <span class="n">l_rlbl</span><span class="p">)</span>

    <span class="c1"># Return the path graph to be merged with the (u, v)-flower graph, and the counter for the next unused integer for node labels.</span>
    <span class="k">return</span> <span class="n">Hl</span><span class="p">,</span> <span class="n">N</span></div>



<span class="c1"># Nested Barabasi-Albert Network</span>

<div class="viewcode-block" id="generate_nested_BA_model_subnetwork">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.generate_nested_BA_model_subnetwork">[docs]</a>
<span class="k">def</span> <span class="nf">generate_nested_BA_model_subnetwork</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">kmax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a Barabasi-Albert (BA) network with maximum degree kmax.</span>
<span class="sd">    Some of this code is from the NetworkX barabasi_albert_graph function.</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int): The number of edges attached to a newly created node in the generation of a BA network.</span>
<span class="sd">        kmax (int): The maximum degree of the BA network.</span>

<span class="sd">    Returns:</span>
<span class="sd">        G (networkx.Graph): The generated BA network.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Begin with a complete graph on m+1 nodes so that each node has m edges.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Generate a list of nodes where each node is repeated as many times as its degree.</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">repeated_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">degrees</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>

    <span class="c1"># The label of the next node is the next available integer, which is N (nodes are labelled from 0 to N-1)</span>
    <span class="n">next_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># Find the maximum degree in the network</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Iterate while the maximum degree is less than kmax</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span><span class="p">:</span>
        <span class="c1"># Choose m target nodes in proportion to their degree.</span>
        <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">preferential_choice</span><span class="p">(</span><span class="n">repeated_nodes</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Add edges between the new node and the m randomly chosen neighbours.</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">next_node</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">))</span>

        <span class="c1"># Add each of the target nodes to the list of repeated nodes once, to represent their newly added edge.</span>
        <span class="n">repeated_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span>
        <span class="c1"># Add the new node m times to the list of repeated nodes.</span>
        <span class="n">repeated_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">next_node</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># Calculate the new maximum degree</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Increment the label for the next node.</span>
        <span class="n">next_node</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Once the maximum degree is kmax, return the generated network.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="preferential_choice">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.modelgenerator.preferential_choice">[docs]</a>
<span class="k">def</span> <span class="nf">preferential_choice</span><span class="p">(</span><span class="n">repeated_nodes</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chooses m nodes at random with probability proportionate to their degree.</span>
<span class="sd">    Some of this code is from the NetworkX barabasi_albert_graph function.</span>

<span class="sd">    Args:</span>
<span class="sd">        repeated_nodes (list): A list of nodes where each node is repeated as many times as its degree.</span>
<span class="sd">        m (int): The number of nodes to be chosen.</span>

<span class="sd">    Returns:</span>
<span class="sd">        target_nodes (set): A set of m chosen nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise an empty set for the target nodes.</span>
    <span class="c1"># We use a set instead of a list so that the m nodes chosen are unique.</span>
    <span class="n">target_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Iterate until m nodes are chosen.</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="c1"># Choose a node at random from the list.</span>
        <span class="c1"># Because each node with degree k is repeated k times the probability of it being chosen is k/2e(G)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">repeated_nodes</span><span class="p">)</span>
        <span class="c1"># Add the chosen node to the set.</span>
        <span class="c1"># If the node has been chosen already, it will not be added again.</span>
        <span class="n">target_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Return the list of chosen nodes.</span>
    <span class="k">return</span> <span class="n">target_nodes</span></div>


</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Fractal Networks</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">fractalnetworks</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Katherine Hamilton.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>