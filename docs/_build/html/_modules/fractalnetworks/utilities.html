<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fractalnetworks.utilities &#8212; Fractal Networks 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for fractalnetworks.utilities</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module contains utility functions used throughout the fractal network toolkit.&quot;&quot;&quot;</span>

<span class="c1"># Network analysis modules</span>
<span class="kn">from</span> <span class="nn">igraph</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="kn">import</span> <span class="nn">igraph</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="c1"># Mathematics modules</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># Utility modules</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">mmread</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="c1"># Reading Graphs</span>


<div class="viewcode-block" id="read_graph">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.read_graph">[docs]</a>
<span class="k">def</span> <span class="nf">read_graph</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks the filetype and calls the correct function to read the graph.</span>
<span class="sd">    For any file not in .gml format, an additional .gml file is created.</span>
<span class="sd">    Supports .mtx, .txt, .edge (.EDGE) and .gml filetypes.</span>

<span class="sd">    Args:</span>
<span class="sd">        filepath (str) : Path for the network file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (igraph.Graph) : The network from the file stored as a graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># .gml files</span>
    <span class="k">if</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gml&quot;</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.mtx&quot;</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">read_mtx_graph_format</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="n">new_filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.mtx&quot;</span><span class="p">,</span> <span class="s2">&quot;.gml&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">new_filepath</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">new_filepath</span><span class="p">)</span>

    <span class="c1"># .txt files</span>
    <span class="k">elif</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="n">new_filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;.gml&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">new_filepath</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">new_filepath</span><span class="p">)</span>

    <span class="c1"># .edge or .EDGE files</span>
    <span class="k">elif</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.edges&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.EDGES&quot;</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_weighted_edgelist</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="n">new_filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.edges&quot;</span><span class="p">,</span> <span class="s2">&quot;.gml&quot;</span><span class="p">)</span>
        <span class="n">new_filepath</span> <span class="o">=</span> <span class="n">new_filepath</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.EDGES&quot;</span><span class="p">,</span> <span class="s2">&quot;.gml&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">new_filepath</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">new_filepath</span><span class="p">)</span>

    <span class="c1"># Raise an error if an unknown file type is used.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This filetype is not supported for network analysis.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="read_mtx_graph_format">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.read_mtx_graph_format">[docs]</a>
<span class="k">def</span> <span class="nf">read_mtx_graph_format</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads graphs stored in the .mtx file format.</span>
<span class="sd">    Use with, for example, graphs from www.networkrepository.com.</span>
<span class="sd">    Some files may need to be edited to make sure that scipy.io can read them.</span>
<span class="sd">    Files should have a header starting with %%MatrixMarket and a single line with the number of values in each column.</span>

<span class="sd">    Args:</span>
<span class="sd">        filepath (str) : Filepath to .mtx file</span>

<span class="sd">    Returns:</span>
<span class="sd">        (networkx.Graph) : Network read from file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the file using the scipy.io file reader.</span>
    <span class="n">mmf</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="c1"># Generate a graph from this file.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_array</span><span class="p">(</span><span class="n">mmf</span><span class="p">)</span>
    <span class="c1"># Return the graph.</span>
    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="exact_log">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.exact_log">[docs]</a>
<span class="k">def</span> <span class="nf">exact_log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the exact logarithm of x base y.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (float) : The value of x.</span>
<span class="sd">        y (float) : The logarithm base.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : Tuple containing an int and bool, specifically:</span>
<span class="sd">                    the floor of the power, where y^power = x;</span>
<span class="sd">                    and value True if x is an exact power of y, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">power</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
        <span class="n">power</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="find_best_power_law_fit">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.find_best_power_law_fit">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_power_law_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the best exponential fit according to the sum of squares deviation of the form y = Ax^{-c}</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list)                          : The values of x in the distribution.</span>
<span class="sd">        y (list)                          : The values of y in the distribution.</span>
<span class="sd">        A_min (:obj:`int`, optional)      : The minimum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        A_max (:obj:`int`, optional)      : The maximum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 10000.</span>
<span class="sd">        c_min (:obj:`int`, optional)      : The minimum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        c_max (:obj:`int`, optional)      : The maximum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 12.5.</span>
<span class="sd">        linspace_N (:obj:`int`, optional) : The number of values of A and c to be checked in the respective ranges.</span>
<span class="sd">                                            Default is 100.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple containing a tuple and float, specifically:</span>
<span class="sd">                    a tuple of the coefficients A and c from the best power law approximation;</span>
<span class="sd">                    and the sum of squares regression of this approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise empty variables for the best fit (i.e. the best A and c) and the best SSR score.</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate through linspace_N values of A in the range [A_min, A_max].</span>
    <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">A_min</span><span class="p">,</span> <span class="n">A_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>
        <span class="c1"># Iterate through linspace_N values of c in the range [c_min, c_max].</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>

            <span class="c1"># Find the values of y according to the power law fractal model with parameters A and c.</span>
            <span class="n">est_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span> <span class="o">*</span> <span class="n">i</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="c1"># Calculate the sum of squares regression.</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">sum_of_squares_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">)</span>

            <span class="c1"># If the best score is yet to be updated (i.e. this is the first iteration)</span>
            <span class="c1">#   then set the current A, c and SSR to the best fit values.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># If the new SSR score is smaller than the current best,</span>
            <span class="c1">#   then update the best score and update the best fit to the current A and c.</span>
            <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Once all values are tried return the best fit and the best score.</span>
    <span class="k">return</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span></div>



<div class="viewcode-block" id="sum_of_squares_error">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.sum_of_squares_error">[docs]</a>
<span class="k">def</span> <span class="nf">sum_of_squares_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the value SSR for the sum of squares regression method using a true and model distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        y (list)     : The true or measured distribution.</span>
<span class="sd">        est_y (list) : The model distribution to be compared.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float) : The sum of squares regression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sum_of_squares</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initialise the sum as zero.</span>
    <span class="c1"># Iterate for each pair of values in the true/model distributions.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">est_yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">):</span>
        <span class="c1"># Add to the sum the square of the difference between the two distributions.</span>
        <span class="n">sum_of_squares</span> <span class="o">+=</span> <span class="p">(</span><span class="n">est_yi</span> <span class="o">-</span> <span class="n">yi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1"># Return the total sum of the squares.</span>
    <span class="k">return</span> <span class="n">sum_of_squares</span></div>



<div class="viewcode-block" id="swap_edges_at_random">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.swap_edges_at_random">[docs]</a>
<span class="k">def</span> <span class="nf">swap_edges_at_random</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">number_edges_to_swap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps edge of a given network at random, to find an uncorrelated network with the same degree distribution.</span>
<span class="sd">    Removes two randomly chosen edges (a,b) and (c,d) and replaces them with edges (a,d) and (c,b).</span>

<span class="sd">    Args:</span>
<span class="sd">        G (igraph.Graph)           : The original network.</span>
<span class="sd">        number_edges_to_swap (int) : The number of edges to swap.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (igraph.Graph) : The new, uncorrelated network with the same degree distribution as G.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a copy of the graph</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Iterate number_edges_to_swap times.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_edges_to_swap</span><span class="p">):</span>

        <span class="c1"># Reset variables for a, b, c and d.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># There are certain bad swaps we could make,</span>
        <span class="c1">#   e.g. swapping (a,b), (c,a) would create a self loop and an edge (c,b) might already exist.</span>
        <span class="c1"># Set this flag to False until we find a good swap.</span>
        <span class="n">good_swap</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Iterate until we find a good swap.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">good_swap</span><span class="p">:</span>
            <span class="c1"># Choose two edges at random from the network</span>
            <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">es</span><span class="p">()),</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Find the endpoints of the edges.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">edge1</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">edge1</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">edge2</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">edge2</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check if (a,d) or (c,b) are self loops.</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
                <span class="c1"># Check if (a,d) or (c,b) already exists.</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="c1"># If neither of these are True, then we have found a good swap.</span>
                    <span class="n">good_swap</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Delete the old edges and add the new ones.</span>
        <span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)])</span>
        <span class="n">H</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)])</span>

    <span class="c1"># Once number_edges_to_swap edges have been swapped, return the new network</span>
    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="plot_scatter_graph">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.plot_scatter_graph">[docs]</a>
<span class="k">def</span> <span class="nf">plot_scatter_graph</span><span class="p">(</span><span class="n">fractal_attribute</span><span class="p">,</span> <span class="n">non_fractal_attribute</span><span class="p">,</span> <span class="n">fractal_Ns</span><span class="p">,</span> <span class="n">non_fractal_Ns</span><span class="p">,</span> <span class="n">y_label</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a comparison of the properties of fractal and non-fractal networks on a scatter graph.</span>

<span class="sd">    Args:</span>
<span class="sd">        fractal_attribute (list)         : A list of an attribute of fractal networks.</span>
<span class="sd">        non_fractal_attribute (list)     : A list of an attribute of non-fractal networks.</span>
<span class="sd">        fractal_Ns (list)                : A list of fractal network orders.</span>
<span class="sd">        non_fractal_Ns (list)            : A list of non-fractal network orders.</span>
<span class="sd">        y_label (str)                    : Label for the y-axis, i.e. the attribute being plotted.</span>
<span class="sd">        save_path (:obj:`str`, optional) : The file path to save the figure to, if given. Default is None.</span>
<span class="sd">        plot (:obj:`bool`, optional)     : If True, display the network. Default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the median of both sets</span>
    <span class="n">fractal_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">fractal_attribute</span><span class="p">)</span>
    <span class="n">non_fractal_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">non_fractal_attribute</span><span class="p">)</span>

    <span class="c1"># The x-axis ranges from the smallest network order N to the largest.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">fractal_Ns</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">non_fractal_Ns</span><span class="p">)),</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">fractal_Ns</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">non_fractal_Ns</span><span class="p">)),</span> <span class="mi">1001</span><span class="p">)</span>

    <span class="c1"># Plot the fractal attribute</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">fractal_Ns</span><span class="p">,</span> <span class="n">fractal_attribute</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;navy&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fractal&quot;</span><span class="p">)</span>
    <span class="c1"># Plot the non-fractal attribute</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">non_fractal_Ns</span><span class="p">,</span> <span class="n">non_fractal_attribute</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;crimson&#39;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Non-fractal&quot;</span><span class="p">)</span>

    <span class="c1"># Plot fractal median</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">fractal_median</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;navy&quot;</span><span class="p">)</span>
    <span class="c1"># Plot non-fractal median</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">non_fractal_median</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;crimson&quot;</span><span class="p">)</span>

    <span class="c1"># Label the axes</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$|G|$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>

    <span class="c1"># Add a legend</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="c1"># If a save path is given, then save the file in that location.</span>
    <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>

    <span class="c1"># If plot is True display the graph</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Close the figure</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="clean_lists_of_NaNs">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.clean_lists_of_NaNs">[docs]</a>
<span class="k">def</span> <span class="nf">clean_lists_of_NaNs</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cleans lists of NaN values before plotting.</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list) : The list to be plotted on the x-axis.</span>
<span class="sd">        list2 (list) : The list to be plotted on the y-axis, to be checked for NaN values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple of two lists, specifically a clean version of list1 and a clean version of list2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find a list of indexes where the value in the second list is NaN</span>
    <span class="n">NaN_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>

    <span class="c1"># Only take the elements of lists not equal to NaN</span>
    <span class="n">list1_clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">list1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NaN_indexes</span><span class="p">]</span>
    <span class="n">list2_clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NaN_indexes</span><span class="p">]</span>

    <span class="c1"># Return the cleaned lists.</span>
    <span class="k">return</span> <span class="n">list1_clean</span><span class="p">,</span> <span class="n">list2_clean</span></div>



<div class="viewcode-block" id="display_network">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.display_network">[docs]</a>
<span class="k">def</span> <span class="nf">display_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Displays a given network.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (igraph.Graph)                 : The network to be displayed.</span>
<span class="sd">        save_path (:obj:`str`, optional) : The filepath to save the figure to, if given. Default is None.</span>
<span class="sd">        plot (:obj:`bool`, optional)     : If True, the network is displayed inline. Default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Plot the network</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">igraph</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                <span class="n">vertex_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">vertex_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">vertex_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                <span class="n">edge_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                <span class="n">layout</span><span class="o">=</span><span class="s2">&quot;kamada_kawai&quot;</span><span class="p">,</span>
                <span class="n">target</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="c1"># If a save path is given, then save the file in that location.</span>
    <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>

    <span class="c1"># If plot is True display the graph</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Close the figure</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="find_best_exp_fit">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.find_best_exp_fit">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_exp_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the best exponential fit of the form y = Ae^{-cx} according to the sum of squares deviation.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list): The values of x in the distribution.</span>
<span class="sd">        y (list): The values of y in the distribution.</span>
<span class="sd">        A_min (:obj:`int`, optional)      : The minimum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        A_max (:obj:`int`, optional)      : The maximum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 100.</span>
<span class="sd">        c_min (:obj:`int`, optional)      : The minimum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        c_max (:obj:`int`, optional)      : The maximum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 2.</span>
<span class="sd">        linspace_N (:obj:`int`, optional) : The number of values of A and c to be checked in the respective ranges.</span>
<span class="sd">                                            Default is 100.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple containing a tuple and float, specifically:</span>
<span class="sd">                    the coefficients A and c from the best exponential approximation;</span>
<span class="sd">                    and the sum of squares regression of this approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise empty variables for the best fit (i.e. the best A and c) and the best SSR score.</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate through linspace_N values of A in the range [A_min, A_max].</span>
    <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">A_min</span><span class="p">,</span> <span class="n">A_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>
        <span class="c1"># Iterate through linspace_N values of c in the range [c_min, c_max].</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>

            <span class="c1"># Find the values of y according to the exponential model with parameters A and c.</span>
            <span class="n">est_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">e</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="c1"># Calculate the sum of squares regression.</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">sum_of_squares_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">)</span>

            <span class="c1"># If the best score is yet to be updated (i.e. this is the first iteration)</span>
            <span class="c1">#   then set the current A, c and SSR to the best fit values.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># If the new SSR score is smaller than the current best,</span>
            <span class="c1">#   then update the best score and update the best fit to the current A and c.</span>
            <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Once all values are tried return the best fit and the best score.</span>
    <span class="k">return</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span></div>



<div class="viewcode-block" id="find_best_fractal_fit">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.find_best_fractal_fit">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_fractal_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the best exponential fit according to the sum of squares deviation of the form y = Ax^{-c}</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list)                          : The values of x in the distribution.</span>
<span class="sd">        y (list)                          : The values of y in the distribution.</span>
<span class="sd">        A_min (:obj:`int`, optional)      : The minimum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        A_max (:obj:`int`, optional)      : The maximum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 10000.</span>
<span class="sd">        c_min (:obj:`int`, optional)      : The minimum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        c_max (:obj:`int`, optional)      : The maximum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 12.5.</span>
<span class="sd">        linspace_N (:obj:`int`, optional) : The number of values of A and c to be checked in the respective ranges.</span>
<span class="sd">                                            Default is 100.</span>

<span class="sd">    Returns:</span>
<span class="sd">        best_fit (tuple)   : The coefficients A and c from the best power law approximation.</span>
<span class="sd">        best_score (float) : The sum of squares regression of this approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise empty variables for the best fit (i.e. the best A and c) and the best SSR score.</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate through linspace_N values of A in the range [A_min, A_max].</span>
    <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">A_min</span><span class="p">,</span> <span class="n">A_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>
        <span class="c1"># Iterate through linspace_N values of c in the range [c_min, c_max].</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>

            <span class="c1"># Find the values of y according to the power law fractal model with parameters A and c.</span>
            <span class="n">est_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span> <span class="o">*</span> <span class="n">i</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="c1"># Calculate the sum of squares regression.</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">sum_of_squares_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">)</span>

            <span class="c1"># If the best score is yet to be updated (i.e. this is the first iteration)</span>
            <span class="c1">#   then set the current A, c and SSR to the best fit values.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># If the new SSR score is smaller than the current best,</span>
            <span class="c1">#   then update the best score and update the best fit to the current A and c.</span>
            <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Once all values are tried return the best fit and the best score.</span>
    <span class="k">return</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span></div>



<div class="viewcode-block" id="find_best_linear_fit">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.find_best_linear_fit">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_linear_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="mi">101</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the best exponential fit according to the sum of squares deviation of the form y = Ax^{-c}</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list)                          : The values of x in the distribution.</span>
<span class="sd">        y (list)                          : The values of y in the distribution.</span>
<span class="sd">        A_min (:obj:`int`, optional)      : The minimum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        A_max (:obj:`int`, optional)      : The maximum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 10000.</span>
<span class="sd">        c_min (:obj:`int`, optional)      : The minimum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        c_max (:obj:`int`, optional)      : The maximum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 12.5.</span>
<span class="sd">        linspace_N (:obj:`int`, optional) : The number of values of A and c to be checked in the respective ranges.</span>
<span class="sd">                                            Default is 100.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple containing a tuple and float, specifically:</span>
<span class="sd">                    the coefficients A and c from the best power law approximation;</span>
<span class="sd">                    and the sum of squares regression of this approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise empty variables for the best fit (i.e. the best A and c) and the best SSR score.</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate through linspace_N values of A in the range [A_min, A_max].</span>
    <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">A_min</span><span class="p">,</span> <span class="n">A_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>
        <span class="c1"># Iterate through linspace_N values of c in the range [c_min, c_max].</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="p">):</span>

            <span class="c1"># Find the values of y according to the power law fractal model with parameters A and c.</span>
            <span class="n">est_y</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
            <span class="c1"># Calculate the sum of squares regression.</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">sum_of_squares_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">est_y</span><span class="p">)</span>

            <span class="c1"># If the best score is yet to be updated (i.e. this is the first iteration)</span>
            <span class="c1">#   then set the current A, c and SSR to the best fit values.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># If the new SSR score is smaller than the current best,</span>
            <span class="c1">#   then update the best score and update the best fit to the current A and c.</span>
            <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Once all values are tried return the best fit and the best score.</span>
    <span class="k">return</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span></div>



<div class="viewcode-block" id="find_best_fit_iteratively">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.find_best_fit_iteratively">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_fit_iteratively</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span> <span class="n">iter_num</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the best fit according to a given model by iteratively reducing the range of values checked for A and c.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list)                          : The values of x in the distribution.</span>
<span class="sd">        y (list)                          : The values of y in the distribution.</span>
<span class="sd">        method (func)                     : A function which finds the best fit to the given distribution</span>
<span class="sd">                                                according to a given model.</span>
<span class="sd">        linspace_N (:obj:`int`, optional) : The number of values of A and c to be checked in the respective ranges.</span>
<span class="sd">                                            Default is 100.</span>
<span class="sd">        A_min (:obj:`int`, optional)      : The minimum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        A_max (:obj:`int`, optional)      : The maximum value of A to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 10000.</span>
<span class="sd">        c_min (:obj:`int`, optional)      : The minimum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 0.</span>
<span class="sd">        c_max (:obj:`int`, optional)      : The maximum value of c to be tested.</span>
<span class="sd">                                            Can be adjusted to find more accurate results. Default is 12.5.</span>
<span class="sd">        iter_num (:obj:`int`, optional)   : The number of iterations to complete.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple containing a tuple and a float, specifically:</span>
<span class="sd">            the coefficients A and c from the best approximation;</span>
<span class="sd">            and the sum of squares regression of this approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find the current range of the intervals for A and c.</span>
    <span class="n">A_diff</span> <span class="o">=</span> <span class="n">A_max</span> <span class="o">-</span> <span class="n">A_min</span>
    <span class="n">c_diff</span> <span class="o">=</span> <span class="n">c_max</span> <span class="o">-</span> <span class="n">c_min</span>

    <span class="c1"># Reset the variables for best fit and best score</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate as many times as dictated by the iter_num variable.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iter_num</span><span class="p">):</span>
        <span class="c1"># Find the best fit in this range according to the intervals given.</span>
        <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A_min</span><span class="o">=</span><span class="n">A_min</span><span class="p">,</span> <span class="n">A_max</span><span class="o">=</span><span class="n">A_max</span><span class="p">,</span> <span class="n">c_min</span><span class="o">=</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="o">=</span><span class="n">c_max</span><span class="p">,</span> <span class="n">linspace_N</span><span class="o">=</span><span class="n">linspace_N</span><span class="p">)</span>

        <span class="c1"># Reduce the interval range for A by a factor of 10 and for c by a factor of 5.</span>
        <span class="n">A_diff</span> <span class="o">=</span> <span class="n">A_diff</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="n">c_diff</span> <span class="o">=</span> <span class="n">c_diff</span> <span class="o">/</span> <span class="mi">5</span>

        <span class="c1"># Extract the values of A and c from the current best fit.</span>
        <span class="n">best_A_approximation</span> <span class="o">=</span> <span class="n">best_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">best_c_approximation</span> <span class="o">=</span> <span class="n">best_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Adjust the interval [A_min, A_max] to have a range of A_diff about the current best estimate for A.</span>
        <span class="n">A_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_A_approximation</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_diff</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">A_max</span> <span class="o">=</span> <span class="n">best_A_approximation</span> <span class="o">+</span> <span class="p">(</span><span class="n">A_diff</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Adjust the interval [c_min, c_max] to have a range of c_diff about the current best estimate for c.</span>
        <span class="n">c_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_c_approximation</span> <span class="o">-</span> <span class="p">(</span><span class="n">c_diff</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="n">best_c_approximation</span> <span class="o">+</span> <span class="p">(</span><span class="n">c_diff</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Once iter_num iterations are complete, return the best fit and best score.</span>
    <span class="k">return</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_score</span></div>



<div class="viewcode-block" id="plot_lB_NB">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.plot_lB_NB">[docs]</a>
<span class="k">def</span> <span class="nf">plot_lB_NB</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the distribution of the optimal number of boxes NB against the diameter of the boxes lB.</span>

<span class="sd">    Args:</span>
<span class="sd">        lB (list) : List of the values of lB.</span>
<span class="sd">        NB (list) : List of the corresponding values of NB.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Plots distribution using matplotlib.</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;The optimal number of boxes $N_B$ against the diameter $\ell_B$.&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_loglog_lB_NB">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.plot_loglog_lB_NB">[docs]</a>
<span class="k">def</span> <span class="nf">plot_loglog_lB_NB</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the distribution of the optimal number of boxes NB against the diameter of the boxes lB on a log-log scale.</span>

<span class="sd">    Args:</span>
<span class="sd">        lB (list) : List of the values of lB.</span>
<span class="sd">        NB (list) : List of the corresponding values of NB.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Plots distribution on log log scale using matplotlib.</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;The optimal number of boxes $N_B$ against the diameter $\ell_B$.&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_best_fit_comparison">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.plot_best_fit_comparison">[docs]</a>
<span class="k">def</span> <span class="nf">plot_best_fit_comparison</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">exp_A</span><span class="p">,</span> <span class="n">exp_c</span><span class="p">,</span> <span class="n">exp_score</span><span class="p">,</span> <span class="n">frac_A</span><span class="p">,</span> <span class="n">frac_c</span><span class="p">,</span> <span class="n">frac_score</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a comparison of the best power law (fractal) and exponential (non-fractal) fit for a given distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        lB (list)          : List of the values of lB.</span>
<span class="sd">        NB (list)          : List of the corresponding values of NB.</span>
<span class="sd">        exp_A (float)      : The optimal value of A according to the exponential fit.</span>
<span class="sd">        exp_c (float)      : The optimal value of c according to the exponential fit.</span>
<span class="sd">        exp_score (float)  : The sum of squares regression for the exponential best fit.</span>
<span class="sd">        frac_A (float)     : The optimal value of A according to the power law fit.</span>
<span class="sd">        frac_c (float)     : The optimal value of c according to the power law fit.</span>
<span class="sd">        frac_score (float) : The sum of squares regression for the power law best fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The lists lB and NB need to be converted to numpy arrays.</span>
    <span class="n">lB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lB</span><span class="p">)</span>
    <span class="n">NB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NB</span><span class="p">)</span>

    <span class="n">est_NB_exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_A</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">e</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">exp_c</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lB</span><span class="p">]</span>  <span class="c1"># Find the exponential fit according to A and c given.</span>
    <span class="n">est_NB_frac</span> <span class="o">=</span> <span class="p">[</span><span class="n">frac_A</span> <span class="o">*</span> <span class="n">i</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">frac_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lB</span><span class="p">]</span>  <span class="c1"># Find the power law fit according to A and c given.</span>

    <span class="c1"># Initialise a plot.</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Plot the distribution against the power law fit.</span>
    <span class="c1"># Note we only use one set of labels for the legend as both plots use the same colours.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000066&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Empirical Data&quot;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">est_NB_frac</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best Fit&quot;</span><span class="p">)</span>

    <span class="c1"># Plot the distribution against the exponential fit.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000066&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">est_NB_exp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">)</span>

    <span class="c1"># Find the maximum x and y values.</span>
    <span class="n">max_lB</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lB</span><span class="p">)</span>
    <span class="n">max_NB</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">NB</span><span class="p">)</span>

    <span class="c1"># Label the axes and title the subplot.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Power-Law Relation&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">max_lB</span><span class="p">,</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">max_NB</span><span class="p">,</span>
                 <span class="sa">r</span><span class="s2">&quot;$SSR \approx $</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac_score</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>  <span class="c1"># Write the SSR score on the plot.</span>

    <span class="c1"># Label the axes and title the subplot.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Exponential Relation&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">max_lB</span><span class="p">,</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">max_NB</span><span class="p">,</span>
                 <span class="sa">r</span><span class="s2">&quot;$SSR \approx $</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">exp_score</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>  <span class="c1"># Write the SSR score on the plot.</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>  <span class="c1"># Add the legend.</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_best_fit_comparison_by_logarithm">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.plot_best_fit_comparison_by_logarithm">[docs]</a>
<span class="k">def</span> <span class="nf">plot_best_fit_comparison_by_logarithm</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">NB</span><span class="p">,</span> <span class="n">exp_A</span><span class="p">,</span> <span class="n">exp_c</span><span class="p">,</span> <span class="n">exp_score</span><span class="p">,</span> <span class="n">frac_A</span><span class="p">,</span> <span class="n">frac_c</span><span class="p">,</span> <span class="n">frac_score</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a comparison of the best power law (fractal) and exponential (non-fractal) fit for a given distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        lB (list)          : List of the values of lB.</span>
<span class="sd">        NB (list)          : List of the corresponding values of NB.</span>
<span class="sd">        exp_A (float)      : The optimal value of A according to the exponential fit.</span>
<span class="sd">        exp_c (float)      : The optimal value of c according to the exponential fit.</span>
<span class="sd">        exp_score (float)  : The sum of squares regression for the exponential best fit.</span>
<span class="sd">        frac_A (float)     : The optimal value of A according to the power law fit.</span>
<span class="sd">        frac_c (float)     : The optimal value of c according to the power law fit.</span>
<span class="sd">        frac_score (float) : The sum of squares regression for the power law best fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loglB</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lB</span><span class="p">]</span>
    <span class="n">logNB</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NB</span><span class="p">]</span>

    <span class="c1"># The lists lB and NB need to be converted to numpy arrays.</span>
    <span class="n">lB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lB</span><span class="p">)</span>
    <span class="n">loglB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loglB</span><span class="p">)</span>
    <span class="n">logNB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">logNB</span><span class="p">)</span>

    <span class="n">est_NB_exp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">exp_c</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">exp_A</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lB</span><span class="p">]</span>  <span class="c1"># Find the exponential fit according to A and c given.</span>
    <span class="n">est_NB_frac</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">frac_c</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">frac_A</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loglB</span><span class="p">]</span>  <span class="c1"># Find the power law fit according to A and c given.</span>

    <span class="c1"># Initialise a plot.</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="c1"># Plot the distribution against the power law fit.</span>
    <span class="c1"># Note we only use one set of labels for the legend as both plots use the same colours.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">logNB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000066&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Empirical Data&quot;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lB</span><span class="p">,</span> <span class="n">est_NB_frac</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best Fit&quot;</span><span class="p">)</span>

    <span class="c1"># Plot the distribution against the exponential fit.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loglB</span><span class="p">,</span> <span class="n">logNB</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000066&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loglB</span><span class="p">,</span> <span class="n">est_NB_exp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#C00000&#39;</span><span class="p">)</span>

    <span class="c1"># Find the maximum x and y values.</span>
    <span class="n">max_lB</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lB</span><span class="p">)</span>
    <span class="n">max_NB</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">NB</span><span class="p">)</span>

    <span class="c1"># Label the axes and title the subplot.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Power-Law Relation&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">max_lB</span><span class="p">,</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">max_NB</span><span class="p">,</span>
                 <span class="sa">r</span><span class="s2">&quot;$SSR \approx $</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac_score</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>  <span class="c1"># Write the SSR score on the plot.</span>

    <span class="c1"># Label the axes and title the subplot.</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Exponential Relation&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$N_B$&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">max_lB</span><span class="p">,</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">max_NB</span><span class="p">,</span>
                 <span class="sa">r</span><span class="s2">&quot;$SSR \approx $</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">exp_score</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>  <span class="c1"># Write the SSR score on the plot.</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>  <span class="c1"># Add the legend.</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>



<div class="viewcode-block" id="draw_box_covering">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.draw_box_covering">[docs]</a>
<span class="k">def</span> <span class="nf">draw_box_covering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodes_to_boxes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Displays the network with nodes coloured according to the box covering.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (igraph.Graph)    : The network to be analysed.</span>
<span class="sd">        nodes_to_boxes (dict) : A dictionary with nodes as keys and their corresponding boxes as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

    <span class="c1"># Initialise an empty colour map for the box covering visualisation.</span>
    <span class="n">colourmap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># For each node, assign it the colour of its box ID.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">colourmap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes_to_boxes</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>

    <span class="c1"># If draw is True then display the graph with the colours indicating the box the node belongs to.</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_kamada_kawai</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">colourmap</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="export_to_gephi">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.export_to_gephi">[docs]</a>
<span class="k">def</span> <span class="nf">export_to_gephi</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodes_to_boxes</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Puts graphs in a format readable to Gephi including attributes for the boxes found under box coverings.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (igraph.Graph)    : The network to be analysed.</span>
<span class="sd">        nodes_to_boxes (dict) : A dictionary with nodes as keys and their corresponding boxes as values.</span>
<span class="sd">        file_path (str)       : The path for the gml file to be saved to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Create a copy of the network.</span>

    <span class="c1"># Assign to each node an attribute according to its box given under the box covering.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">vs</span><span class="p">():</span>
        <span class="n">H</span><span class="o">.</span><span class="n">vs</span><span class="p">()[</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">][</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_to_boxes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Write the graph including the box covering attributes to the file path.</span>
    <span class="n">H</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;gml&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="chi_squared_error">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.chi_squared_error">[docs]</a>
<span class="k">def</span> <span class="nf">chi_squared_error</span><span class="p">(</span><span class="n">observed_y</span><span class="p">,</span> <span class="n">expected_y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the chi squared value using a true and model distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        observed_y (list) : The true or measured distribution.</span>
<span class="sd">        expected_y (list) : The model distribution to be compared.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float) : The chi squared value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initialise the sum as zero.</span>
    <span class="c1"># Iterate for each pair of values in the true/model distributions.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">observed_yi</span><span class="p">,</span> <span class="n">expected_yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">observed_y</span><span class="p">,</span> <span class="n">expected_y</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expected_yi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add to the sum the square of the difference between the two distributions.</span>
            <span class="n">chi</span> <span class="o">+=</span> <span class="p">(((</span><span class="n">observed_yi</span> <span class="o">-</span> <span class="n">expected_yi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">expected_yi</span><span class="p">)</span>
    <span class="c1"># Return the total sum of the squares.</span>
    <span class="k">return</span> <span class="n">chi</span></div>



<div class="viewcode-block" id="read_lB_NB_from_csv">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.read_lB_NB_from_csv">[docs]</a>
<span class="k">def</span> <span class="nf">read_lB_NB_from_csv</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads the lB-NB distribution from a csv file.</span>

<span class="sd">    Args:</span>
<span class="sd">        filepath (str) : The filepath to the .csv file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple) : A tuple of two lists.</span>
<span class="sd">                    The first contains all box diameters lB, the second contains the corresponding values of NB.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find csv file.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lB</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">NB</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return lists</span>
    <span class="k">return</span> <span class="n">lB</span><span class="p">,</span> <span class="n">NB</span></div>



<div class="viewcode-block" id="preprocess_network">
<a class="viewcode-back" href="../../fractalnetworks.html#fractalnetworks.utilities.preprocess_network">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_network</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses a network to simplify and take the giant component.</span>

<span class="sd">    Args:</span>
<span class="sd">        filepath (str)               : The filepath of the network .gml file.</span>
<span class="sd">        save (:obj:`bool`, optional) : If True, saves the processed network to a new gml file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (igraph.Graph) : The processed network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find network</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="c1"># Remove multi-edges and self-loops</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="c1"># Find the giant component.</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;weak&#39;</span><span class="p">)</span>
    <span class="n">giant_component</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.gml&#39;</span><span class="p">,</span> <span class="s1">&#39;_processed.gml&#39;</span><span class="p">)</span>
        <span class="n">giant_component</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">giant_component</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Fractal Networks</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">fractalnetworks</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Katherine Hamilton.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>